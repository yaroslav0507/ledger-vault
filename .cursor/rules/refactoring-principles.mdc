---
description:
globs:
alwaysApply: false
---
# LedgerVault Refactoring Principles

## Core Design Principles

### DRY (Don't Repeat Yourself)
- **Extract common logic** into reusable functions, hooks, or services
- **Identify patterns** across components and create shared abstractions
- **Consolidate similar functionality** rather than duplicating code
- **Use composition** over inheritance to build complex components from simple ones

### Single Responsibility Principle (SRP)
- Each component, function, or class should have **one clear purpose**
- **Separate concerns**: UI logic, business logic, and data management
- **Break down large components** into smaller, focused pieces
- Example: [AnalyticsService.ts](mdc:src/features/analytics/service/AnalyticsService.ts) handles only analytics calculations

### Separation of Concerns
- **UI Components**: Focus only on rendering and user interaction
- **Services**: Handle business logic and data processing like [AnalyticsService.ts](mdc:src/features/analytics/service/AnalyticsService.ts)
- **Stores**: Manage state and data flow like [transactionStore.ts](mdc:src/features/transactions/store/transactionStore.ts)
- **Utilities**: Provide common helper functions in [src/shared/utils/](mdc:src/shared/utils)

## Code Quality Standards

### Component Size Limits
- **Components should not exceed 300 lines**
- **Functions should not exceed 50 lines**
- **Classes should not exceed 500 lines**
- If exceeded, break down using composition patterns

### State Management
- **Limit useState hooks to 5 per component**
- **Extract complex state logic into custom hooks**
- **Use useReducer for complex state with multiple related values**
- **Prefer derived state over storing computed values**

### Function Parameters
- **Maximum 4 parameters per function**
- **Use object parameters for functions with more than 3 arguments**
- **Prefer configuration objects over long parameter lists**

## Anti-Patterns to Avoid

### Code Duplication
- ❌ **Copying and pasting** similar components or functions
- ❌ **Hardcoding values** that could be parameterized
- ❌ **Repeating business logic** across different modules
- ✅ **Extract common patterns** into shared utilities or components

### God Components/Functions
- ❌ **Large components** that handle multiple responsibilities
- ❌ **Functions with many parameters** or complex logic
- ✅ **Break down into smaller pieces** with clear responsibilities
- ✅ **Use composition** to build complex functionality

### Tight Coupling
- ❌ **Direct dependencies** between unrelated modules
- ❌ **Hardcoded imports** from specific feature modules
- ✅ **Use dependency injection** and interfaces
- ✅ **Communicate through props** and callbacks

## Refactoring Guidelines

### When to Extract Common Code
- **Same logic appears 3+ times**: Extract into shared utility
- **Similar components**: Create a base component with props
- **Complex calculations**: Move to service layer
- **State management patterns**: Create custom hooks

### Implementation Guidelines

#### Before Adding New Code
1. **Search for existing solutions** in the codebase
2. **Check shared utilities** in [src/shared/](mdc:src/shared)
3. **Look for similar patterns** in other features
4. **Consider if logic can be generalized** for reuse

#### When Creating New Components
1. **Start with props interface** to define the API
2. **Keep components pure** when possible (no side effects)
3. **Extract complex logic** into custom hooks or services
4. **Use composition** to combine simpler components

#### When Writing Business Logic
1. **Place in service classes** like [AnalyticsService](mdc:src/features/analytics/service/AnalyticsService.ts)
2. **Make functions pure** and testable
3. **Use consistent patterns** across similar operations
4. **Document complex algorithms** and business rules
